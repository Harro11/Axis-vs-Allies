<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Axis & Allies: WWII 1942 - Advanced</title>
    <script src="https://cdn.jsdelivr.net/npm/react@18.3.1/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18.3.1/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/zustand@4.5.5/dist/zustand.umd.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@3.4.14/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        #map { height: 80vh; }
        .modal { backdrop-filter: blur(5px); }
        .territory-germany { color: #dc2626; font-weight: 700; }
        .territory-japan { color: #dc2626; font-weight: 700; }
        .territory-united_kingdom { color: #2563eb; font-weight: 700; }
        .territory-soviet_union { color: #2563eb; font-weight: 700; }
        .territory-united_states { color: #2563eb; font-weight: 700; }
        .territory-neutral { color: #6b7280; font-weight: 700; }
        .unit-icon { width: 20px; height: 20px; }
        .animate-move { animation: moveUnit 0.5s ease; }
        @keyframes moveUnit { 0% { transform: translateY(10px); opacity: 0; } 100% { transform: translateY(0); opacity: 1; } }
        .theme-dark { background-color: #1f2937; color: #f3f4f6; }
        .theme-dark .bg-white { background-color: #374151; }
        .theme-dark .border-gray-100 { border-color: #4b5563; }
    </style>
</head>
<body class="bg-gray-50 font-sans antialiased transition-colors duration-300" id="app-root">
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/babel-standalone@6.26.0/babel.min.js"></script>
    <script type="text/babel">
        const { create } = Zustand;

        // Game constants
        const UNITS = {
            infantry: { cost: 3, attack: 1, defense: 2, move: 1, type: 'land', icon: 'üë®‚ÄçüöÄ' },
            artillery: { cost: 4, attack: 2, defense: 2, move: 1, type: 'land', boostsInfantry: true, icon: 'üéØ' },
            tank: { cost: 6, attack: 3, defense: 3, move: 2, type: 'land', icon: 'üöú' },
            fighter: { cost: 10, attack: 3, defense: 4, move: 4, type: 'air', icon: '‚úàÔ∏è' },
            bomber: { cost: 12, attack: 4, defense: 1, move: 6, type: 'air', icon: 'üí£' },
            aaa: { cost: 5, attack: 0, defense: 1, move: 1, type: 'land', antiAir: true, icon: 'üî´' },
            submarine: { cost: 6, attack: 2, defense: 1, move: 2, type: 'sea', surpriseStrike: true, icon: 'üö§' },
            destroyer: { cost: 8, attack: 2, defense: 2, move: 2, type: 'sea', icon: '‚õµ' },
            cruiser: { cost: 12, attack: 3, defense: 3, move: 2, type: 'sea', icon: 'üö¢' },
            battleship: { cost: 20, attack: 4, defense: 4, move: 2, type: 'sea', icon: '‚öì' },
            carrier: { cost: 16, attack: 1, defense: 2, move: 2, type: 'sea', carries: 2, icon: 'üõ´' },
            transport: { cost: 7, attack: 0, defense: 1, move: 2, type: 'sea', carries: 2, icon: '‚õ¥Ô∏è' }
        };

        const NATION_SYMBOLS = {
            Germany: 'üá©üá™', Japan: 'üáØüáµ', United_Kingdom: 'üá¨üáß', Soviet_Union: 'üá∑üá∫', United_States: 'üá∫üá∏', Neutral: '‚ö™'
        };

        const TERRITORIES = [
            { name: "Germany", coords: [51.1657, 10.4515], owner: "Germany", ipcs: 10, units: { infantry: 6, tank: 3, fighter: 2, aaa: 1 }, isCapital: true, factory: true, victoryCity: true },
            { name: "Southern Europe", coords: [42.5, 12.5], owner: "Germany", ipcs: 2, units: { infantry: 2, artillery: 1 }, factory: true },
            { name: "Western Europe", coords: [48.5, 2.5], owner: "Germany", ipcs: 6, units: { infantry: 3, tank: 1, aaa: 1 }, factory: true },
            { name: "Norway", coords: [64, 10], owner: "Germany", ipcs: 2, units: { infantry: 2 } },
            { name: "Finland", coords: [65, 25], owner: "Germany", ipcs: 1, units: { infantry: 1 } },
            { name: "Eastern Europe", coords: [50, 25], owner: "Germany", ipcs: 3, units: { infantry: 3, tank: 1 } },
            { name: "Ukraine", coords: [48, 30], owner: "Germany", ipcs: 3, units: { infantry: 2, artillery: 1 } },
            { name: "Caucasus", coords: [43, 45], owner: "Soviet_Union", ipcs: 3, units: { infantry: 2 }, factory: true },
            { name: "Russia", coords: [55, 37], owner: "Soviet_Union", ipcs: 10, units: { infantry: 6, tank: 2, fighter: 1, aaa: 1 }, isCapital: true, factory: true, victoryCity: true },
            { name: "Archangel", coords: [64, 40], owner: "Soviet_Union", ipcs: 2, units: { infantry: 1 } },
            { name: "Karelia S.S.R.", coords: [62, 30], owner: "Soviet_Union", ipcs: 2, units: { infantry: 2, artillery: 1 }, factory: true },
            { name: "United Kingdom", coords: [55.3781, -3.4360], owner: "United_Kingdom", ipcs: 8, units: { infantry: 2, fighter: 2, bomber: 1, aaa: 1 }, isCapital: true, factory: true, victoryCity: true },
            { name: "Gibraltar", coords: [36, -5], owner: "United_Kingdom", ipcs: 0, units: { infantry: 1 } },
            { name: "Egypt", coords: [30, 31], owner: "United_Kingdom", ipcs: 2, units: { infantry: 2, tank: 1 }, victoryCity: true },
            { name: "Union of South Africa", coords: [-30, 25], owner: "United_Kingdom", ipcs: 2, units: { infantry: 1 }, factory: true },
            { name: "French West Africa", coords: [15, -5], owner: "Neutral", ipcs: 1, units: { infantry: 1 } },
            { name: "French Equatorial Africa", coords: [0, 15], owner: "Neutral", ipcs: 1, units: { infantry: 1 } },
            { name: "Italian East Africa", coords: [5, 40], owner: "Germany", ipcs: 1, units: { infantry: 1 } },
            { name: "Libya", coords: [25, 20], owner: "Germany", ipcs: 1, units: { infantry: 1 } },
            { name: "Morocco", coords: [32, -5], owner: "Neutral", ipcs: 1, units: { infantry: 1 } },
            { name: "Japan", coords: [36.2048, 138.2529], owner: "Japan", ipcs: 8, units: { infantry: 6, fighter: 2, bomber: 1, aaa: 1 }, isCapital: true, factory: true, victoryCity: true },
            { name: "Manchuria", coords: [45, 125], owner: "Japan", ipcs: 3, units: { infantry: 2, artillery: 1 } },
            { name: "Kiangsu", coords: [32, 120], owner: "Japan", ipcs: 3, units: { infantry: 2, fighter: 1 } },
            { name: "India", coords: [20, 77], owner: "United_Kingdom", ipcs: 3, units: { infantry: 3, artillery: 1, aaa: 1 }, factory: true, victoryCity: true },
            { name: "Burma", coords: [22, 95], owner: "United_Kingdom", ipcs: 1, units: { infantry: 1 } },
            { name: "French Indo-China", coords: [15, 105], owner: "Japan", ipcs: 2, units: { infantry: 1 } },
            { name: "China", coords: [35, 105], owner: "United_States", ipcs: 2, units: { infantry: 4 } },
            { name: "Szechwan", coords: [30, 100], owner: "United_States", ipcs: 2, units: { infantry: 1 } },
            { name: "Yunnan", coords: [25, 100], owner: "United_States", ipcs: 1, units: { infantry: 1 } },
            { name: "Kwangtung", coords: [22, 115], owner: "United_Kingdom", ipcs: 3, units: { infantry: 1 }, victoryCity: true },
            { name: "Philippines", coords: [15, 120], owner: "United_States", ipcs: 2, units: { infantry: 2 }, victoryCity: true },
            { name: "Hawaii", coords: [20, -155], owner: "United_States", ipcs: 1, units: { infantry: 1, fighter: 1 } },
            { name: "Australia", coords: [-25, 135], owner: "United_Kingdom", ipcs: 3, units: { infantry: 2, artillery: 1 }, factory: true, victoryCity: true },
            { name: "New Zealand", coords: [-40, 175], owner: "United_Kingdom", ipcs: 1, units: { infantry: 1 } },
            { name: "Caroline Islands", coords: [5, 155], owner: "Japan", ipcs: 0, units: { infantry: 1 } },
            { name: "Solomon Islands", coords: [-10, 160], owner: "Japan", ipcs: 0, units: { infantry: 1 } },
            { name: "New Guinea", coords: [-5, 145], owner: "Japan", ipcs: 1, units: { infantry: 1 } },
            { name: "Dutch New Guinea", coords: [-5, 135], owner: "Neutral", ipcs: 1, units: { infantry: 1 } },
            { name: "United States", coords: [37.0902, -95.7129], owner: "United_States", ipcs: 17, units: { infantry: 3, fighter: 2, bomber: 1, aaa: 1 }, isCapital: true, factory: true, victoryCity: true },
            { name: "Alaska", coords: [65, -150], owner: "United_States", ipcs: 1, units: { infantry: 1 } },
            { name: "Central America", coords: [10, -85], owner: "United_States", ipcs: 1, units: { infantry: 1 } },
            { name: "Sea Zone 6", coords: [55, -10], owner: "Neutral", ipcs: 0, units: { destroyer: 1, transport: 1 }, sea: true },
            { name: "Sea Zone 17", coords: [35, 145], owner: "Neutral", ipcs: 0, units: { carrier: 1, fighter: 2, destroyer: 1 }, sea: true }
        ];

        // Zustand store
        const useGameStore = create((set, get) => ({
            mode: 'hotseat',
            currentNation: 'Germany',
            turnOrder: ['Germany', 'Soviet Union', 'Japan', 'United States', 'United Kingdom'],
            currentPhase: 'Research & Development',
            ipcs: { Germany: 30, Soviet_Union: 28, Japan: 26, United_States: 42, United_Kingdom: 28 },
            purchasedUnits: {},
            combat: [],
            selectedTerritory: null,
            territories: TERRITORIES,
            markers: [],
            sessionId: null,
            players: { Germany: 'human', Soviet_Union: 'human', Japan: 'human', United_States: 'human', United_Kingdom: 'human' },
            isDarkMode: false,
            isTutorial: false,
            chatMessages: [],
            analytics: { battles: 0, ipcsSpent: 0 },
            setMode: (mode) => set({ mode, players: mode === 'computer' ? { Germany: 'computer', Soviet_Union: 'human', Japan: 'computer', United_States: 'human', United_Kingdom: 'human' } : { Germany: 'human', Soviet_Union: 'human', Japan: 'human', United_States: 'human', United_Kingdom: 'human' } }),
            setPhase: (phase) => set({ currentPhase: phase }),
            setNation: (nation) => set({ currentNation: nation }),
            selectTerritory: (territory) => set({ selectedTerritory: territory }),
            toggleDarkMode: () => set((state) => ({ isDarkMode: !state.isDarkMode })),
            addChat: (msg) => set((state) => ({ chatMessages: [...state.chatMessages, { sender: state.currentNation, text: msg, time: new Date().toLocaleTimeString() }] })),
            updateAnalytics: (key, value) => set((state) => ({ analytics: { ...state.analytics, [key]: state.analytics[key] + value } })),
            saveGame: () => {
                const state = get();
                localStorage.setItem(`a&a_${state.sessionId || 'local'}`, JSON.stringify(state));
            },
            resetGame: () => set({
                mode: 'hotseat',
                currentNation: 'Germany',
                turnOrder: ['Germany', 'Soviet Union', 'Japan', 'United States', 'United Kingdom'],
                currentPhase: 'Research & Development',
                ipcs: { Germany: 30, Soviet_Union: 28, Japan: 26, United_States: 42, United_Kingdom: 28 },
                purchasedUnits: {},
                combat: [],
                selectedTerritory: null,
                territories: TERRITORIES,
                markers: [],
                sessionId: null,
                players: { Germany: 'human', Soviet_Union: 'human', Japan: 'human', United_States: 'human', United_Kingdom: 'human' },
                chatMessages: [],
                analytics: { battles: 0, ipcsSpent: 0 }
            })
        }));

        // Game logic
        const GameLogic = {
            parsePurchaseInput: (input) => {
                const purchases = {};
                let totalCost = 0;
                input.split(',').map(item => item.trim().split(' ')).forEach(([count, type]) => {
                    const num = parseInt(count);
                    if (UNITS[type] && !isNaN(num) && num > 0) {
                        totalCost += num * UNITS[type].cost;
                        purchases[type] = (purchases[type] || 0) + num;
                    }
                });
                const ipcs = useGameStore.getState().ipcs[useGameStore.getState().currentNation];
                return totalCost <= ipcs ? { purchases, totalCost } : null;
            },
            canMoveUnits: (territory, unitsToMove) => {
                for (const [type, count] of Object.entries(unitsToMove)) {
                    if (!territory.units[type] || territory.units[type] < count) return false;
                }
                return true;
            },
            conductCombat: () => {
                const { combat, currentNation, updateAnalytics } = useGameStore.getState();
                combat.forEach(({ attacker, defender, units: attackingUnits }) => {
                    let attackerPower = 0, defenderPower = 0;
                    let infantryBoosted = 0;
                    for (const [type, count] of Object.entries(attackingUnits)) {
                        if (type === 'artillery' && infantryBoosted < count) infantryBoosted += count;
                        attackerPower += count * (UNITS[type].attack || 0);
                        if (UNITS[type].surpriseStrike && !defender.units.destroyer) attackerPower += count;
                    }
                    if (attackingUnits.infantry && infantryBoosted > 0) attackerPower += Math.min(attackingUnits.infantry, infantryBoosted);
                    for (const [type, count] of Object.entries(defender.units)) {
                        defenderPower += count * (UNITS[type].defense || 0);
                    }
                    if (defender.units.aaa && Object.keys(attackingUnits).some(type => UNITS[type].type === 'air')) {
                        const airUnits = Object.entries(attackingUnits).reduce((sum, [type, count]) => sum + (UNITS[type].type === 'air' ? count : 0), 0);
                        const aaaHits = Math.min(defender.units.aaa, Math.floor(Math.random() * airUnits));
                        GameLogic.reduceUnits(attackingUnits, aaaHits);
                    }
                    const attackerHits = Math.floor(Math.random() * (attackerPower / 2 + 1));
                    const defenderHits = Math.floor(Math.random() * (defenderPower / 2 + 1));
                    GameLogic.reduceUnits(attackingUnits, defenderHits);
                    GameLogic.reduceUnits(defender.units, attackerHits);
                    const attackerRemaining = Object.values(attackingUnits).reduce((sum, count) => sum + count, 0);
                    const defenderRemaining = Object.values(defender.units).reduce((sum, count) => sum + count, 0);
                    if (defenderRemaining === 0 && attackerRemaining > 0) {
                        defender.owner = currentNation;
                        defender.units = { ...attackingUnits };
                        if (defender.factory) defender.factoryDamage = 0;
                        alert(`${currentNation} captures ${defender.name}!`);
                    } else if (attackerRemaining === 0) {
                        alert(`${currentNation}'s attack on ${defender.name} failed!`);
                    } else {
                        alert(`Combat in ${defender.name} ongoing.`);
                    }
                    updateAnalytics('battles', 1);
                });
                useGameStore.setState({ combat: [] });
                GameLogic.checkGameOver();
            },
            reduceUnits: (unitSet, hits) => {
                let remainingHits = hits;
                for (const type of Object.keys(UNITS)) {
                    while (remainingHits > 0 && unitSet[type] > 0) {
                        unitSet[type]--;
                        remainingHits--;
                    }
                }
            },
            checkGameOver: () => {
                const { territories, resetGame } = useGameStore.getState();
                const axisVictoryCities = territories.filter(t => t.victoryCity && (t.owner === 'Germany' || t.owner === 'Japan')).length;
                const alliesVictoryCities = territories.filter(t => t.victoryCity && (t.owner === 'Soviet_Union' || t.owner === 'United_Kingdom' || t.owner === 'United_States')).length;
                const axisCapitals = territories.filter(t => t.isCapital && (t.owner === 'Germany' || t.owner === 'Japan')).length;
                const alliesCapitals = territories.filter(t => t.isCapital && (t.owner === 'Soviet_Union' || t.owner === 'United_Kingdom' || t.owner === 'United_States')).length;
                if (axisCapitals === 0 || alliesVictoryCities >= 12) {
                    alert('Allies win!');
                    resetGame();
                } else if (alliesCapitals === 0 || axisVictoryCities >= 12) {
                    alert('Axis win!');
                    resetGame();
                }
            },
            runAITurn: () => {
                const { currentPhase, currentNation, ipcs, territories, purchasedUnits, selectTerritory, setPhase, combat, updateAnalytics } = useGameStore.getState();
                switch (currentPhase) {
                    case 'Research & Development':
                        if (ipcs[currentNation] >= 5 && Math.random() < 0.3) {
                            useGameStore.setState(state => ({ ipcs: { ...state.ipcs, [currentNation]: state.ipcs[currentNation] - 5 } }));
                            updateAnalytics('ipcsSpent', 5);
                        }
                        setPhase('Purchase Units');
                        break;
                    case 'Purchase Units':
                        const purchases = { infantry: Math.floor(ipcs[currentNation] * 0.7 / 3), tank: Math.floor(ipcs[currentNation] * 0.3 / 6) };
                        const cost = purchases.infantry * 3 + purchases.tank * 6;
                        useGameStore.setState(state => ({
                            purchasedUnits: { ...state.purchasedUnits, [currentNation]: purchases },
                            ipcs: { ...state.ipcs, [currentNation]: state.ipcs[currentNation] - cost }
                        }));
                        updateAnalytics('ipcsSpent', cost);
                        setPhase('Combat Move');
                        break;
                    case 'Combat Move':
                        const aiTerritories = territories.filter(t => t.owner === currentNation && Object.values(t.units).reduce((sum, c) => sum + c, 0) > 2);
                        const target = territories.find(t => t.owner !== currentNation && t.ipcs > 1 && Object.values(t.units).reduce((sum, c) => sum + c, 0) <= 3);
                        if (aiTerritories.length && target) {
                            selectTerritory(aiTerritories[0]);
                            const unitsToMove = { infantry: Math.min(2, aiTerritories[0].units.infantry || 0), tank: Math.min(1, aiTerritories[0].units.tank || 0) };
                            useGameStore.setState(state => ({
                                combat: [...state.combat, { attacker: aiTerritories[0], defender: target, units: unitsToMove }]
                            }));
                            for (const [type, count] of Object.entries(unitsToMove)) {
                                aiTerritories[0].units[type] -= count;
                            }
                        }
                        setPhase('Conduct Combat');
                        break;
                    case 'Conduct Combat':
                        if (combat.length > 0) GameLogic.conductCombat();
                        else setPhase('Non-Combat Move');
                        break;
                    case 'Non-Combat Move':
                        const source = territories.find(t => t.owner === currentNation && t.units.infantry > 2);
                        const dest = territories.find(t => t.owner === currentNation && t !== source && t.ipcs > 1);
                        if (source && dest) {
                            dest.units.infantry = (dest.units.infantry || 0) + 1;
                            source.units.infantry -= 1;
                        }
                        setPhase('Mobilize New Units');
                        break;
                    case 'Mobilize New Units':
                        const factory = territories.find(t => t.owner === currentNation && t.factory);
                        if (factory && purchasedUnits[currentNation]) {
                            selectTerritory(factory);
                            const factoryLimit = factory.ipcs - (factory.factoryDamage || 0);
                            const purchasedCount = Object.values(purchasedUnits[currentNation]).reduce((sum, count) => sum + count, 0);
                            if (purchasedCount <= factoryLimit) {
                                factory.units = { ...factory.units, ...purchasedUnits[currentNation] };
                                useGameStore.setState(state => ({ purchasedUnits: { ...state.purchasedUnits, [currentNation]: null } }));
                            }
                        }
                        setPhase('Collect Income');
                        break;
                    case 'Collect Income':
                        const income = territories.filter(t => t.owner === currentNation && !t.sea).reduce((sum, t) => sum + t.ipcs, 0);
                        useGameStore.setState(state => ({ ipcs: { ...state.ipcs, [currentNation]: state.ipcs[currentNation] + income } }));
                        GameLogic.nextPhase();
                        break;
                }
            },
            nextPhase: () => {
                const { currentPhase, currentNation, turnOrder, setPhase, setNation, players, saveGame } = useGameStore.getState();
                const phases = ['Research & Development', 'Purchase Units', 'Combat Move', 'Conduct Combat', 'Non-Combat Move', 'Mobilize New Units', 'Collect Income'];
                const currentIndex = phases.indexOf(currentPhase);
                const nextPhaseIndex = (currentIndex + 1) % phases.length;
                setPhase(phases[nextPhaseIndex]);
                if (nextPhaseIndex === 0) {
                    const nationIndex = turnOrder.indexOf(currentNation);
                    const nextNation = turnOrder[(nationIndex + 1) % turnOrder.length];
                    setNation(nextNation);
                    useGameStore.setState({ selectedTerritory: null });
                    if (players[nextNation] === 'computer') GameLogic.runAITurn();
                }
                saveGame();
            }
        };

        // Components
        const Modal = ({ isOpen, onClose, title, children }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 modal flex items-center justify-center z-50" role="dialog" aria-labelledby="modal-title">
                    <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl max-w-md w-full">
                        <h2 id="modal-title" className="text-xl font-bold mb-4 dark:text-white">{title}</h2>
                        {children}
                        <button onClick={onClose} className="mt-4 bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">Close</button>
                    </div>
                </div>
            );
        };

        const GameMap = React.memo(() => {
            const [map, setMap] = React.useState(null);
            const selectTerritory = useGameStore(state => state.selectTerritory);
            React.useEffect(() => {
                const leafletMap = L.map('map').setView([20, 0], 2);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
                }).addTo(leafletMap);
                setMap(leafletMap);
                return () => leafletMap.remove();
            }, []);
            React.useEffect(() => {
                if (!map) return;
                const { territories } = useGameStore.getState();
                const markers = territories.map(territory => {
                    const markerClass = `territory-${territory.owner.toLowerCase()}`;
                    const symbol = NATION_SYMBOLS[territory.owner] || '‚ö™';
                    const marker = L.marker(territory.coords, {
                        icon: L.divIcon({
                            className: markerClass,
                            html: `<span>${symbol} ${territory.name}${territory.victoryCity ? ' üèõÔ∏è' : ''}${territory.factory ? ' üè≠' : ''}</span>`
                        })
                    }).addTo(map);
                    marker.on('click', () => selectTerritory(territory));
                    return marker;
                });
                return () => markers.forEach(marker => map.removeLayer(marker));
            }, [map, selectTerritory]);
            return <div id="map" className="rounded-lg shadow-lg border border-gray-200"></div>;
        });

        const GamePanel = () => {
            const { mode, currentNation, ipcs, currentPhase, selectedTerritory, setMode, setPhase, saveGame, resetGame, isTutorial, addChat } = useGameStore();
            const [modal, setModal] = React.useState({ isOpen: false, type: null, data: {} });
            const handlePhaseAction = () => {
                switch (currentPhase) {
                    case 'Research & Development':
                        setModal({ isOpen: true, type: 'research', data: {} });
                        break;
                    case 'Purchase Units':
                        setModal({ isOpen: true, type: 'purchase', data: {} });
                        break;
                    case 'Combat Move':
                        if (selectedTerritory && selectedTerritory.owner === currentNation) {
                            setModal({ isOpen: true, type: 'combatMove', data: {} });
                        } else {
                            alert('Select a friendly territory!');
                        }
                        break;
                    case 'Conduct Combat':
                        if (useGameStore.getState().combat.length > 0) GameLogic.conductCombat();
                        else GameLogic.nextPhase();
                        break;
                    case 'Non-Combat Move':
                        if (selectedTerritory && selectedTerritory.owner === currentNation) {
                            setModal({ isOpen: true, type: 'nonCombatMove', data: {} });
                        } else {
                            alert('Select a friendly territory!');
                        }
                        break;
                    case 'Mobilize New Units':
                        if (useGameStore.getState().purchasedUnits[currentNation] && selectedTerritory && selectedTerritory.factory) {
                            const factoryLimit = selectedTerritory.ipcs - (selectedTerritory.factoryDamage || 0);
                            const purchasedCount = Object.values(useGameStore.getState().purchasedUnits[currentNation]).reduce((sum, count) => sum + count, 0);
                            if (purchasedCount <= factoryLimit) {
                                selectedTerritory.units = { ...selectedTerritory.units, ...useGameStore.getState().purchasedUnits[currentNation] };
                                useGameStore.setState(state => ({ purchasedUnits: { ...state.purchasedUnits, [currentNation]: null } }));
                                alert(`Units mobilized in ${selectedTerritory.name}!`);
                                GameLogic.nextPhase();
                            } else {
                                alert(`Factory can only mobilize ${factoryLimit} units!`);
                            }
                        } else {
                            alert('Select a territory with a factory!');
                        }
                        break;
                    case 'Collect Income':
                        const income = useGameStore.getState().territories
                            .filter(t => t.owner === currentNation && !t.sea)
                            .reduce((sum, t) => sum + t.ipcs, 0);
                        useGameStore.setState(state => ({ ipcs: { ...state.ipcs, [currentNation]: state.ipcs[currentNation] + income } }));
                        alert(`${currentNation} collects ${income} IPCs!`);
                        GameLogic.nextPhase();
                        break;
                }
            };
            const handleModalSubmit = (data) => {
                switch (modal.type) {
                    case 'research':
                        if (ipcs[currentNation] >= 5 && data.confirm) {
                            useGameStore.setState(state => ({ ipcs: { ...state.ipcs, [currentNation]: state.ipcs[currentNation] - 5 } }));
                            useGameStore.getState().updateAnalytics('ipcsSpent', 5);
                        }
                        GameLogic.nextPhase();
                        break;
                    case 'purchase':
                        const result = GameLogic.parsePurchaseInput(data.units);
                        if (result) {
                            useGameStore.setState(state => ({
                                purchasedUnits: { ...state.purchasedUnits, [currentNation]: result.purchases },
                                ipcs: { ...state.ipcs, [currentNation]: state.ipcs[currentNation] - result.totalCost }
                            }));
                            useGameStore.getState().updateAnalytics('ipcsSpent', result.totalCost);
                            alert('Units purchased!');
                            GameLogic.nextPhase();
                        } else {
                            alert('Invalid purchase or insufficient IPCs!');
                        }
                        break;
                    case 'combatMove':
                        const targetTerritory = useGameStore.getState().territories.find(t => t.name.toLowerCase() === data.target.toLowerCase());
                        if (!targetTerritory || targetTerritory.owner === currentNation) {
                            alert('Invalid target!');
                            return;
                        }
                        if (!selectedTerritory.units || Object.values(selectedTerritory.units).reduce((sum, count) => sum + count, 0) <= 0) {
                            alert('No units to attack with!');
                            return;
                        }
                        const movingUnits = GameLogic.parsePurchaseInput(data.units)?.purchases;
                        if (!movingUnits || !GameLogic.canMoveUnits(selectedTerritory, movingUnits)) {
                            alert('Invalid units or insufficient units to move!');
                            return;
                        }
                        useGameStore.setState(state => ({
                            combat: [...state.combat, { attacker: selectedTerritory, defender: targetTerritory, units: movingUnits }]
                        }));
                        for (const [type, count] of Object.entries(movingUnits)) {
                            selectedTerritory.units[type] -= count;
                        }
                        alert(`Combat move planned against ${targetTerritory.name}!`);
                        GameLogic.nextPhase();
                        break;
                    case 'nonCombatMove':
                        const targetNonCombat = useGameStore.getState().territories.find(t => t.name.toLowerCase() === data.target.toLowerCase());
                        if (!targetNonCombat || targetNonCombat.owner !== currentNation) {
                            alert('Invalid target!');
                            return;
                        }
                        if (selectedTerritory === targetNonCombat) {
                            alert('Cannot move to the same territory!');
                            return;
                        }
                        const movingNonCombatUnits = GameLogic.parsePurchaseInput(data.units)?.purchases;
                        if (!movingNonCombatUnits || !GameLogic.canMoveUnits(selectedTerritory, movingNonCombatUnits)) {
                            alert('Invalid units or insufficient units to move!');
                            return;
                        }
                        for (const [type, count] of Object.entries(movingNonCombatUnits)) {
                            targetNonCombat.units[type] = (targetNonCombat.units[type] || 0) + count;
                            selectedTerritory.units[type] -= count;
                        }
                        alert(`Units moved to ${targetNonCombat.name}!`);
                        GameLogic.nextPhase();
                        break;
                }
                setModal({ isOpen: false, type: null, data: {} });
            };
            return (
                <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg border border-gray-100 dark:border-gray-700">
                    <h3 className="text-lg font-bold mb-4 dark:text-white">Game Controls</h3>
                    <div className="space-y-2 text-sm dark:text-gray-300">
                        <p><span className="font-medium">Mode:</span> {mode === 'hotseat' ? 'Hot Seat' : mode === 'computer' ? 'Vs. Computer' : 'Online'}</p>
                        <p><span className="font-medium">Nation:</span> {currentNation}</p>
                        <p><span className="font-medium">IPCs:</span> {ipcs[currentNation]}</p>
                        <p><span className="font-medium">Phase:</span> {currentPhase}</p>
                        <p><span className="font-medium">Territory:</span> {selectedTerritory ? selectedTerritory.name : 'None'}</p>
                        {selectedTerritory && (
                            <div className="mt-3">
                                <p><span className="font-medium">IPCs:</span> {selectedTerritory.ipcs}</p>
                                <p className="font-medium">Units:</p>
                                <ul className="list-disc pl-4 text-xs">
                                    {Object.entries(selectedTerritory.units)
                                        .filter(([_, count]) => count > 0)
                                        .map(([type, count]) => (
                                            <li key={type} className="animate-move"><span className="unit-icon">{UNITS[type].icon}</span> {type}: {count}</li>
                                        ))}
                                </ul>
                                <p className="text-xs italic dark:text-gray-400">
                                    {[
                                        selectedTerritory.isCapital ? 'Capital' : '',
                                        selectedTerritory.victoryCity ? 'Victory City' : '',
                                        selectedTerritory.factory ? 'Factory' : ''
                                    ].filter(Boolean).join(', ')}
                                </p>
                            </div>
                        )}
                    </div>
                    <button
                        onClick={handlePhaseAction}
                        className="bg-blue-600 text-white px-4 py-2 rounded w-full mt-4 hover:bg-blue-700 transition"
                        aria-label={`Complete ${currentPhase}`}
                    >
                        Complete Phase
                    </button>
                    <div className="mt-4 space-y-2">
                        <label htmlFor="game-mode-select" className="text-sm font-medium dark:text-white">Game Mode:</label>
                        <select
                            id="game-mode-select"
                            value={mode}
                            onChange={(e) => setMode(e.target.value)}
                            className="border border-gray-300 dark:border-gray-600 rounded px-2 py-1 w-full text-sm dark:bg-gray-700 dark:text-white"
                        >
                            <option value="hotseat">Hot Seat</option>
                            <option value="computer">Vs. Computer</option>
                            <option value="online">Online Multiplayer</option>
                        </select>
                        {mode === 'online' && (
                            <div className="flex gap-2">
                                <input
                                    id="session-id"
                                    type="text"
                                    placeholder="Session ID"
                                    className="border border-gray-300 dark:border-gray-600 rounded px-2 py-1 flex-1 text-sm dark:bg-gray-700 dark:text-white"
                                    onChange={(e) => {
                                        const id = e.target.value;
                                        if (id) {
                                            useGameStore.setState({ sessionId: id });
                                            const saved = localStorage.getItem(`a&a_${id}`);
                                            if (saved) {
                                                useGameStore.setState(JSON.parse(saved));
                                                alert('Joined session!');
                                            } else {
                                                alert('New session created!');
                                                saveGame();
                                            }
                                        }
                                    }}
                                />
                                <button
                                    className="bg-blue-600 text-white px-3 py-1 rounded hover:bg-blue-700 transition"
                                    onClick={() => addChat('Joined the game!')}
                                >
                                    Join
                                </button>
                            </div>
                        )}
                    </div>
                    <button
                        onClick={resetGame}
                        className="bg-gray-500 text-white px-4 py-2 rounded w-full mt-4 hover:bg-gray-600 transition"
                        aria-label="Reset Game"
                    >
                        Reset Game
                    </button>
                    <Modal
                        isOpen={modal.isOpen}
                        onClose={() => setModal({ isOpen: false, type: null, data: {} })}
                        title={modal.type === 'research' ? 'Research & Development' : modal.type === 'purchase' ? 'Purchase Units' : modal.type === 'combatMove' ? 'Combat Move' : 'Non-Combat Move'}
                    >
                        {modal.type === 'research' && (
                            <div>
                                <p className="dark:text-gray-300">Spend 5 IPCs to attempt research? (No tech in this version)</p>
                                <button
                                    onClick={() => handleModalSubmit({ confirm: true })}
                                    className="bg-blue-600 text-white px-4 py-2 rounded mt-4 hover:bg-blue-700"
                                >
                                    Confirm
                                </button>
                            </div>
                        )}
                        {modal.type === 'purchase' && (
                            <div>
                                <p className="dark:text-gray-300">Available IPCs: {ipcs[currentNation]}</p>
                                <p className="text-xs dark:text-gray-400">Enter units (e.g., "2 infantry, 1 tank")</p>
                                <input
                                    type="text"
                                    className="border border-gray-300 dark:border-gray-600 rounded px-2 py-1 w-full mt-2 dark:bg-gray-700 dark:text-white"
                                    onChange={(e) => setModal(state => ({ ...state, data: { units: e.target.value } }))}
                                />
                                <button
                                    onClick={() => handleModalSubmit(modal.data)}
                                    className="bg-blue-600 text-white px-4 py-2 rounded mt-4 hover:bg-blue-700"
                                >
                                    Purchase
                                </button>
                            </div>
                        )}
                        {modal.type === 'combatMove' && (
                            <div>
                                <p className="dark:text-gray-300">Select target territory to attack:</p>
                                <input
                                    type="text"
                                    placeholder="Target territory"
                                    className="border border-gray-300 dark:border-gray-600 rounded px-2 py-1 w-full mt-2 dark:bg-gray-700 dark:text-white"
                                    onChange={(e) => setModal(state => ({ ...state, data: { ...state.data, target: e.target.value } }))}
                                />
                                <p className="text-xs dark:text-gray-400 mt-2">Enter units to move (e.g., "2 infantry, 1 tank")</p>
                                <input
                                    type="text"
                                    className="border border-gray-300 dark:border-gray-600 rounded px-2 py-1 w-full mt-2 dark:bg-gray-700 dark:text-white"
                                    onChange={(e) => setModal(state => ({ ...state, data: { ...state.data, units: e.target.value } }))}
                                />
                                <button
                                    onClick={() => handleModalSubmit(modal.data)}
                                    className="bg-blue-600 text-white px-4 py-2 rounded mt-4 hover:bg-blue-700"
                                >
                                    Attack
                                </button>
                            </div>
                        )}
                        {modal.type === 'nonCombatMove' && (
                            <div>
                                <p className="dark:text-gray-300">Select friendly territory to move to:</p>
                                <input
                                    type="text"
                                    placeholder="Target territory"
                                    className="border border-gray-300 dark:border-gray-600 rounded px-2 py-1 w-full mt-2 dark:bg-gray-700 dark:text-white"
                                    onChange={(e) => setModal(state => ({ ...state, data: { ...state.data, target: e.target.value } }))}
                                />
                                <p className="text-xs dark:text-gray-400 mt-2">Enter units to move (e.g., "2 infantry, 1 tank")</p>
                                <input
                                    type="text"
                                    className="border border-gray-300 dark:border-gray-600 rounded px-2 py-1 w-full mt-2 dark:bg-gray-700 dark:text-white"
                                    onChange={(e) => setModal(state => ({ ...state, data: { ...state.data, units: e.target.value } }))}
                                />
                                <button
                                    onClick={() => handleModalSubmit(modal.data)}
                                    className="bg-blue-600 text-white px-4 py-2 rounded mt-4 hover:bg-blue-700"
                                >
                                    Move
                                </button>
                            </div>
                        )}
                    </Modal>
                </div>
            );
        };

        const Dashboard = () => {
            const { ipcs, territories, currentNation, analytics, chatMessages, addChat } = useGameStore();
            const [chatInput, setChatInput] = React.useState('');
            const axisVictoryCities = territories.filter(t => t.victoryCity && (t.owner === 'Germany' || t.owner === 'Japan')).length;
            const alliesVictoryCities = territories.filter(t => t.victoryCity && (t.owner === 'Soviet_Union' || t.owner === 'United_Kingdom' || t.owner === 'United_States')).length;
            return (
                <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg border border-gray-100 dark:border-gray-700 mt-6">
                    <h3 className="text-lg font-bold mb-4 dark:text-white">Dashboard</h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <p className="text-sm dark:text-gray-300"><span className="font-medium">Victory Cities:</span> Axis: {axisVictoryCities}, Allies: {alliesVictoryCities}</p>
                            <p className="text-sm dark:text-gray-300"><span className="font-medium">Battles Fought:</span> {analytics.battles}</p>
                            <p className="text-sm dark:text-gray-300"><span className="font-medium">IPCs Spent:</span> {analytics.ipcsSpent}</p>
                        </div>
                        <div>
                            <h4 className="text-sm font-medium dark:text-white">Chat</h4>
                            <div className="h-32 overflow-y-auto border border-gray-300 dark:border-gray-600 p-2 text-xs dark:bg-gray-700 dark:text-gray-300">
                                {chatMessages.map((msg, i) => (
                                    <p key={i}><strong>{msg.sender}:</strong> {msg.text} <span className="text-gray-500">({msg.time})</span></p>
                                ))}
                            </div>
                            <div className="flex mt-2">
                                <input
                                    type="text"
                                    value={chatInput}
                                    onChange={(e) => setChatInput(e.target.value)}
                                    className="border border-gray-300 dark:border-gray-600 rounded px-2 py-1 flex-1 text-sm dark:bg-gray-700 dark:text-white"
                                    placeholder="Type a message..."
                                />
                                <button
                                    onClick={() => { addChat(chatInput); setChatInput(''); }}
                                    className="bg-blue-600 text-white px-3 py-1 rounded ml-2 hover:bg-blue-700"
                                >
                                    Send
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const App = () => {
            const isDarkMode = useGameStore(state => state.isDarkMode);
            const toggleDarkMode = useGameStore(state => state.toggleDarkMode);
            React.useEffect(() => {
                document.body.classList.toggle('theme-dark', isDarkMode);
            }, [isDarkMode]);
            return (
                <div className="container mx-auto px-4 py-6">
                    <header className="bg-blue-950 text-white py-4 rounded-lg shadow-md mb-6">
                        <div className="flex justify-between items-center px-4">
                            <h1 className="text-2xl font-bold">Axis & Allies: WWII 1942</h1>
                            <button
                                onClick={toggleDarkMode}
                                className="bg-gray-700 text-white px-3 py-1 rounded hover:bg-gray-800"
                                aria-label="Toggle Dark Mode"
                            >
                                {isDarkMode ? '‚òÄÔ∏è' : 'üåô'}
                            </button>
                        </div>
                    </header>
                    <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                        <div className="lg:col-span-2">
                            <GameMap />
                        </div>
                        <div className="lg:col-span-1">
                            <GamePanel />
                        </div>
                    </div>
                    <Dashboard />
                    <footer className="mt-6 text-center text-xs text-gray-500 dark:text-gray-400">
                        ¬© 2025 Axis & Allies Interactive. For educational use.
                    </footer>
                </div>
            );
        };

        ReactDOM.render(<App />, document.getElementById('app-root'));
    </script>
</body>
</html>
